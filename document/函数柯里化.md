# 函数柯里化
### 什么是柯里化？
柯里化：是把接受多个参数的函数变换为接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数技术。

举个例子：
```
// 这是一个正常函数的调用
function add (a , b) {
    return a + b;
};
add(1 , 2);

// 将上面的函数进行柯里化，则变为
function curry (a) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return a + args[0];
    }
}
curry(1)(2)
```
### 实现
```
let curry = function (fn) {
    let args = Array.prototype.slice.call(arguments , 1);
    return function () {
        let newArgs = args.concat(Array.prototype.slice.call(arguments));
        return fn.apply(this , newArgs);
    }
};
```

```
let curryAdd1 = curry(add , 1 , 2);
console.log(curryAdd1())

let curryAdd2 = curry(add , 1);
console.log(curryAdd2(2));

let curryAdd3 = curry(add);
console.log(curryAdd3(1 , 2));
```
如果我们能够实现函数这样调用那就比较完美了：

```
fn(1)(2)(3)
```
我们可以这样来实现，从上面的调用，我们可以看到，当调用fn(1)的时候，返回的是一个函数，然后再调用fn(2)的时候，返回的也还是一个函数，然后再调用fn(3)的时候，返回的就是结果。
```
function second_curry (fn) {
    let args = Array.prototype.slice.call(arguments , 1);
    return function () {
        let newArgs = args.concat(Array.prototype.slice.call(arguments));
        return fn.apply(this , newArgs);
    }
};

function curry (fn , len) {
    len = len || fn.length;
    return function () {
        if (arguments.length < len) {
            let arr = [fn].concat(Array.prototype.slice.call(arguments));
            return curry(second_curry.apply(this , arr) , len - arguments.length);
        } else {
            return fn.apply(this , arguments);
        }
    }
}
```

```
function add (a , b , c) {
    return a + b + c;
};
let fn = curry(add);
console.log(fn(1)(3)(4))
```
通过上面代码，可以正确执行，其实调用的次数就是根据传入的参数的个数来判断的。
